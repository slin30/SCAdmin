% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/call.Get_Segments.R
\name{call.Get_Segments}
\alias{call.Get_Segments}
\title{Get Adobe Analytics Segments information}
\usage{
call.Get_Segments(accessLevel = NULL, fields = NULL, selected = NULL,
  sort = NULL, filters = NULL, ...)
}
\arguments{
\item{accessLevel}{(optional) A character vector of length 1. Must be one of \code{all, shared, owned}. 
If not specified, defaults to \code{owned}.}

\item{fields}{(optional) A character vector denoting the quantity, depth, and general detail of information desired. 
Must be one of 
\code{tags, shares, description, owner, modified, compatibility, favorite, reportSuiteID, definition}. 
The API always includes \code{id} and \code{name}, by default.}

\item{selected}{(optional) A character vector of segment ID(s) you wish to query for. If both \code{selected} and 
\code{accessLevel} are provided, \code{selected} take precedence.}

\item{sort}{(optional) A character vector of length 1. Must be one of \code{id, name, description, reportSuiteID,
owner, modified, favorite}. If not specified, defaults to \code{id}.}

\item{filters}{(optional) A named \code{list}. Valid names include
\code{approved, favorite, name, owner, reportSuiteID, tags}. For \code{tags}, character vectors of length > 1 are supported, 
and will be collapsed into comma-separated vectors of length 1 per API requirements. For the other fields, the API supports 
only vectors of length 1.}

\item{...}{Additional args to pass to \code{ApiRequest}}
}
\value{
A data.frame, possibly with nested columns depending on requested parameters within \emph{fields}. Notably, 
the following values in \emph{fields} return list-columns of varying complexity:

\itemize{
\item{tags}
\item{shares}
\item{compatibility}
\item{definition}
}

The number of rows corresponds to the number of unique segments, identified by the \code{id} field. With default
settings, a successful return will contain two fields, \code{id} and \code{name}.
}
\description{
Query the AA segments API to return segment information based on different criteria, at 
the level of desired detail
}
\details{
\emph{filters} has some nuances; there are only six fields that are grouped by argument length, then type:

\itemize{
\itemize{length 1, \code{character}
    \item{name}
    \item{owner}
    \item{reportSuiteID}
    }
\itemize{length 1, \code{logical} (or coercible to logical, without generating \code{NA})
    \item{approved}
    \item{favorite}
    }
\itemize{> length 1, \code{character}
    \item{tags}
    }
}

It is an error to violate any of the above rules (i.e. length or type) for \emph{filters}. It is not strictly
required that e.g. \code{name = c("name1", "name2")} throw an error, as it is a simple matter to only select the 
first element and trigger a \code{warning} (instead). The decision to \code{stop} is to ensure that allowable inputs
and actual results (i.e. end-user expectations) are synchronized, with a custom error message.
}
\note{
It is expected that once the full method is completed, this function will no longer be required by itself, 
although likely will still be exported for flexibility and debugging.
}
\examples{
# These should be thrown into tests; being lazy for now
\dontrun{
# Get your segments, with id and name; no restructuring required
my_own_simple <- call.Get_Segments()

# filters must be a list
call.Get_Segments(filters = c("A", "a"))
# filters must be a named list
call.Get_Segments(filters = list("A", "B"))
# filters must be a named list, and all names must be valid
call.Get_Segments(filters = list(name = "A", alt="B"))
# filters named elements of name, owner, reportSuiteID must be vectors of length 1
call.Get_Segments(filters = list(reportSuiteID = c("rsid1", "rsid2")))
call.Get_Segments(filters = list(owner = c("person1", "person2")))
call.Get_Segments(filters = list(name = c("name1", "name2")))
# filters named elements of approved, favorite must be vectors of length 1 AND 
#  logical, or coercible to logical
call.Get_Segments(filters = list(approved = c("person1", "person2")))
call.Get_Segments(filters = list(approved = c("person1")))
call.Get_Segments(filters = list(favorite = c("person1", "person2")))
call.Get_Segments(filters = list(favorite = c("person1")))

# accessLevel must be vector of length 1
call.Get_Segments(accessLevel = c("all", "owned"))
# accessLevel cannot contain invalid values
call.Get_Segments(accessLevel = "A")
# although if you pass in a list, helper will coerce to vector
## this works:
call.Get_Segments(accessLevel = list("owned")) 

# sort must be a vector of length 1
call.Get_Segments(sort = 1:2)
# sort cannot contain invalid values
call.Get_Segments(sort = 1)
# although if you pass in a list, helper will coerce to vector
## this works:
call.Get_Segments(sort = list("name")) 

# fields must contain valid values
## error; always get `id`, but not allowed value:
call.Get_Segments(fields = c("id"))
# fields must contain ALL valid values
## 'reportSuiteID' is valid, 'id' is not
call.Get_Segments(fields = c("id", "reportSuiteID")) 
## this works:
call.Get_Segments(fields = c("owner", "reportSuiteID"))
# if you pass in a list, helper will coerce to vector
call.Get_Segments(fields = list("owner", "reportSuiteID"))

# Parsing is needed for certain fields, in particular 'definition'
# This returns some nested fields
needs_parsing_1 <- call.Get_Segments(fields = c("tags", "shares", "compatibility"))
# `definition` is the most complex
needs_parsing_2 <- call.Get_Segments(fields = c("definition"))
# Here's what it looks like if we ask for all fields
needs_parsing_3 <- call.Get_Segments(fields = c("compatibility", "definition", 
                                                "favorite", "modified", 
                                                "owner", "reportSuiteID", 
                                                "shares", "tags")
                                     )
}
}
\seealso{
Other get segments functions: \code{\link{restr.Get_Segments}}
}


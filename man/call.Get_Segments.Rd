% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/call.Get_Segments.R
\name{call.Get_Segments}
\alias{call.Get_Segments}
\title{Get Adobe Analytics Segments information}
\usage{
call.Get_Segments(accessLevel = NULL, fields = NULL, selected = NULL,
  sort = NULL, filters = NULL, ...)
}
\arguments{
\item{accessLevel}{(optional) A character vector of length 1. Must be one of \code{all, shared, owned}. 
If not specified, defaults to \code{owned}.}

\item{fields}{(optional) A character vector denoting the quantity, depth, and general detail of information desired. 
Must be one of 
\code{tags, shares, description, owner, modified, compatibility, favorite, reportSuiteID, definition}. 
The API always includes \code{id} and \code{name}, by default.}

\item{selected}{(optional) A character vector of segment ID(s) you wish to query for. If both \code{selected} and 
\code{accessLevel} are provided, \code{selected} take precedence.}

\item{sort}{(optional) A character vector of length 1. Must be one of \code{id, name, description, reportSuiteID,
owner, modified, favorite}. If not specified, defaults to \code{id}.}

\item{filters}{(optional) A named \code{list}. Valid names include
\code{approved, favorite, name, owner, reportSuiteID, tags}. For \code{tags}, character vectors of length > 1 are supported, 
and will be collapsed into comma-separated vectors of length 1 per API requirements. For the other fields, the API supports 
only vectors of length 1.}

\item{...}{Additional args to pass to \code{ApiRequest}}
}
\value{
A \code{data.frame}, possibly with nested columns depending on requested parameters within \emph{fields}. Notably, 
the following values in \emph{fields} return list-columns of varying complexity:

\itemize{
\item{tags}
\item{shares}
\item{compatibility}
\item{definition}
}

The number of rows corresponds to the number of unique segments, identified by the \code{id} field. With default
settings, a successful return will contain two fields, \code{id} and \code{name}.
}
\description{
Query the AA segments API to return segment information based on different criteria, at 
the level of desired detail
}
\details{
This function calls the Adobe Analytics \emph{Segments.Get} method, which supercedes the deprecated 
\emph{ReportSuite.GetSegments} method. The \emph{Segments.Get} method, and therefore this function, 
allows essentially all available information about one or more segments to be returned.

This means that it is now possible to download one or more complete segment definitions, which
may be useful for batch auditing, back-up, and much more. Importantly, the new method operates at the segment
ownership level, as opposed to the reportsuite ID level, which means you should expect your results with 
the simplest call to \emph{Segments.Get} (via this function) to be different from the analagous call to
(the now-deprecated) \emph{ReportSuite.GetSegments}.

Aside from some fields previously returned by \emph{ReportSuite.GetSegments}, which are no longer supported
by \emph{Segments.Get}, it is still possible to operate at the reportsuite ID level through the new \emph{filters}
argument. Note that \emph{filters} has some nuances; there are six fields, which are grouped by argument length,
then type, below:

\itemize{
\itemize{length 1, \code{character}
    \item{name}
    \item{owner}
    \item{reportSuiteID}
    }
\itemize{length 1, \code{logical} (or coercible to logical, without generating \code{NA})
    \item{approved}
    \item{favorite}
    }
\itemize{> length 1, \code{character}
    \item{tags}
    }
}

The \code{filters} argument as a whole is optional, but if used, the input must be a named list, where
the name(s) denote the field(s) to filter, by the provided value. Of the six available fields, only 
\code{tags} accepts inputs of length \code{>1}. Passing vectors of length \code{>1} to any of the other
fields will raise an error.
}
\note{
It is expected that once the full method is completed, this function will no longer be required by itself, 
although likely will still be exported for flexibility and debugging.
}
\examples{
\dontrun{
# Get your segments, with id and name; no restructuring required
my_own_simple <- call.Get_Segments()

# Parsing is needed for certain fields, in particular 'definition'
# This returns some nested fields
needs_parsing_1 <- call.Get_Segments(fields = c("tags", "shares", "compatibility"))
# `definition` is the most complex
needs_parsing_2 <- call.Get_Segments(fields = c("definition"))
# Here's what it looks like if we ask for all fields
needs_parsing_3 <- call.Get_Segments(fields = c("compatibility", "definition", 
                                                "favorite", "modified", 
                                                "owner", "reportSuiteID", 
                                                "shares", "tags")
                                     )
}
}
\seealso{
Other get segments functions: \code{\link{restr.Get_Segments}}
}


% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/call.Get_Segments.R
\name{call.Get_Segments}
\alias{call.Get_Segments}
\title{Get Adobe Analytics Segments}
\usage{
call.Get_Segments(accessLevel = NULL, fields = NULL, selected = NULL,
  sort = NULL, filters = NULL, ...)
}
\arguments{
\item{accessLevel}{(optional) A character vector of length 1. Must be one of \code{all, shared, owned}. 
If not specified, defaults to \code{owned}.}

\item{fields}{(optional) A character vector denoting the quantity, depth, and general detail of information desired. 
Must be one of 
\code{tags, shares, description, owner, modified, compatibility, favorite, reportSuiteID, definition}. 
The API always includes \code{id} and \code{name}, by default.}

\item{selected}{(optional) A character vector of segment ID(s) you wish to query for. If both \code{selected} and 
\code{accessLevel} are provided, \code{selected} take precedence.}

\item{sort}{(optional) A character vector of length 1. Must be one of \code{id, name, description, reportSuiteID,
owner, modified, favorite}. If not specified, defaults to \code{id}.}

\item{filters}{(optional) A named \code{list}. Valid names include
\code{approved, favorite, name, owner, reportSuiteID, tags}. For \code{tags}, character vectors of length > 1 are supported, 
and will be collapsed into comma-separated vectors of length 1 per API requirements. For the other fields, the API supports 
only vectors of length 1.}

\item{...}{(optional) Additional args to pass to \code{ApiRequest}}
}
\value{
A \code{data.frame}, possibly with nested columns depending on requested parameters within \emph{fields}. Notably, 
the following values in \emph{fields} return list-columns of varying complexity:

\itemize{
\item{tags}
\item{shares}
\item{compatibility}
\item{definition}
}

The number of rows corresponds to the number of unique segments, identified by the \code{id} field. With default
settings, a successful return will contain two fields, \code{id} and \code{name}.
}
\description{
Query the Adobe Analytics Segments.Get method to return segment information
}
\details{
This function calls the Adobe Analytics 1.4
\href{https://marketing.adobe.com/developer/documentation/segments-1-4/r-get-1}{Segments.Get}
method, which supercedes the deprecated \emph{ReportSuite.GetSegments} method. 
The \emph{Segments.Get} method, and therefore this function, 
allows essentially all available information about one or more segments to be returned.

As such, it is now possible to download one or more complete segment definitions, which
may be useful for batch auditing, back-up, and much more. Note, though, that \emph{Segments.Get}
operates at the segment ownership level, as opposed to the reportsuite ID level, 
which means this is not a strict replacement for the (deprecated) \emph{ReportSuite.GetSegments} method.

It is possible to constrain results at the reportsuite ID (and more) level through the new \emph{filters}
argument. Note that \emph{filters} has some nuances; there are six fields, which are grouped by argument length,
then type, below:

\itemize{
\itemize{length 1, \code{character}; partial case insensitive matching
    \item{name}
    \item{owner}
    \item{reportSuiteID}
    }
\itemize{length 1, \code{logical} (or coercible to logical, without
          generating \code{NA}); \code{TRUE}/\code{FALSE} selection
    \item{approved}
    \item{favorite}
    }
\itemize{> length 1, \code{character}; exact matching
    \item{tags}
    }
}

The \code{filters} argument as a whole is optional, but if used, the input must be a named list, where
the name(s) denote the field(s) to filter, by the provided value. Of the six available fields, only 
\code{tags} accepts inputs of length \code{>1}. Passing vectors of length \code{>1} to any of the other
fields will raise an error.
}
\note{
\itemize{
\item \strong{This function calls an Adobe Analytics method that requires administrative/elevated privileges}
\item The fields \code{folder,class,suite_enabled}, and \code{read_only} are not supported by \code{Segments.Get}
}
}
\examples{
\dontrun{
# Get your segments, with id and name; no parsing required
my_own_simple <- call.Get_Segments()

# Parsing is needed for certain fields, in particular 'definition'
# This returns some nested fields
needs_parsing_1 <- call.Get_Segments(fields = c("tags", "shares", "compatibility"))
# `definition` is the most complex
needs_parsing_2 <- call.Get_Segments(fields = c("definition"))
# Here's what it looks like if we ask for all fields
needs_parsing_3 <- call.Get_Segments(fields = c("compatibility", "definition", 
                                                "favorite", "modified", 
                                                "owner", "reportSuiteID", 
                                                "shares", "tags")
                                     )
}
}


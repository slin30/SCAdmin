% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flatten_nested_defn.R
\name{flatten_nested_defn}
\alias{flatten_nested_defn}
\title{Flatten a nested definition return}
\usage{
flatten_nested_defn(x, d = 0L, out = list())
}
\arguments{
\item{x}{The return from a call to Segments.Get with a named element of \emph{definition}}

\item{d}{Internal counter to track recursion iterations}

\item{out}{Accumulator for results}
}
\value{
A list, currently taking one of two possible patterns, both of which apply to single
homogeneous cases:

Nested rules, i.e. a definiton where \emph{rules} is nested within \emph{containers}, 
will return a list of length 2, with named elements of \code{res,rules}. 

Nested containers, i.e. a definitions where \emph{container} is nested within \emph{rules}, 
will return a list of length \emph{n}, where \emph{n} is the number of nested containers. 

Stacked segments are not meaningfully parsed, but they are flattened into a more readable 
structure (for now).
}
\description{
Flatten the definition return data structure for nested container(s) and rule(s)
}
\details{
This function attempts to flatten a definition return, and should be used only
on single-row data frames. It is being exported during development, but will likely
not be exported for the first release. 

There remain two edge cases that are not handled; the base method (on Adobe's end) 
currently cannot parse certain definitions, namely those with a \emph{then} operator. 
In fact, when a single such segment is a part of a set of returns, via \emph{Segments.Get}, 
the entire \code{definition} type is \code{list}, rather than \code{data.frame}. Furthremore,
the return value for the unparsable \emph{definition(s)} is a message along the lines of e.g:

\itemize{
\item \code{failed converting segment definition: failed converting container rule: datetime-within}
}

This function will pass such cases through, untouched; this may change (i.e. raise an error)
in the near future. 

The second case involves complex nesting patterns, where a nested container contains nested rules
contains nested containers, and so forth. In the unlikely event it was necessary to create a segment
in such a manner to begin with, you are on your own when it comes to parsing, and this function
will error when it encounters these scenarios. 

When complete, however, this function will at least fail gracefully. It will also likely call
\code{\link{split_segment_ret}}, so that it operates row-wise for a return.
}
\note{
This is not yet complete. There are several helper functions that are not exported, and this
function may not be exported when final, and instead wrapped in a public-facing function with
more consistent return structures and more error checking.
}
\examples{
# TBD
}
